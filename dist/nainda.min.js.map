{"version":3,"sources":["nainda.js"],"names":["isMatch","string_1","string_2","t","a","length","b","lowest_score","a_len","b_len","n","y0","Infinity","x","i","y","s","skips","charCodeAt","match_found","z","sift","powder","sieve","grain","Nainda"],"mappings":"aAAA,IAAMA,QAAU,SAACC,EAAUC,EAAUC,GACnC,IAAIC,OAAAA,EADAJ,OAAAA,EACAI,EAAAA,OAAGH,EAAAI,QACPD,EAAIE,EACJA,EAAIJ,IAAJE,EAAAH,EAKEG,EAAIH,GAON,IAAIM,IALHC,EAAAJ,EAAAC,OAEKI,EADUJ,EAAAA,OACAA,EAAhB,EAAA,EAAAF,EACMO,GAAID,EACNE,EAASC,EAAAA,EACTL,EAAAA,EAAAA,EAAAA,EAAeK,IAAAA,CAKjB,IAJF,IAAKC,EAAIC,EACHD,EAAIF,EACJI,EAAIJ,EACJK,EAAO,EACPC,EAAAA,EAAWN,EAAAM,GAAA,CACf,IAAOF,EAAIP,EAAAA,WAAaS,GAAS,GAAAb,EAAAc,WAAAL,KAAAP,EAAAY,WAAAH,GAC/BF,IACAE,QACEF,CAIA,IAHAE,IAAAA,EAAAA,EAFFI,GAIK,EACCC,GAAOjB,GAAA,CACX,GAAIgB,IAAAA,EAAAA,WAAJJ,EAAAK,GAAA,CACAL,EAAOK,EAAKjB,EAAG,EACbU,IAAkCG,GAAAI,EAChCL,GAAIK,EACJP,GAAK,EACLG,MAEAG,IAEDA,IACDC,IACDP,IACDG,MAGEA,GAAAA,GAAAA,EACD,OAAA,EAEJA,EAAAT,IACDA,EAAYS,GAEXL,IAECJ,OAAAA,GAAAJ,GAGHkB,KAAA,SAAAC,EAAAC,EAAApB,GACD,OAAQI,EAAAA,OAAAA,SAAgBJ,GAxD1B,OAAAH,QAAAwB,EAAAD,EAAApB,MA6DIsB,QACDzB,QAAAA,QAHHqB,KAAAA","file":"nainda.min.js","sourcesContent":["const isMatch = (string_1, string_2, t) => {\n  let a; // shorter string\n  let b; // longer string\n  if (string_2.length < string_1.length) {\n    a = string_2;\n    b = string_1;\n  }\n  else {\n    a = string_1;\n    b = string_2;\n  }\n  const a_len = a.length;\n  const b_len = b.length;\n  const n = b_len - a_len + 1 + (2 * t); // total number of alignments\n  let y0 = -t; // first index of b to be compared for this alignment\n  let lowest_score = Infinity;\n  for (let i=0; i<n; i++) {\n    let x = 0; // index of a currently being compared\n    let y = y0; // index of b currently being compared\n    let s = 0; // score for this alignment\n    let skips = 0; // skip count for this alignment\n    while (y < a_len + y0 + skips) { // go until you run out of characters in a\n      const a_ch = a.charCodeAt(x);\n      if (a.charCodeAt(x) === b.charCodeAt(y)) { //\n        x++;\n        y++;\n      }\n      else {\n        let z = 1; // add-on to y\n        let match_found = false;\n        while (z <= t) {\n          if (a_ch === b.charCodeAt(y+z)) { // if a skip of z results in a match\n            y = y + z + 1; // set new y\n            x++; // set new x\n            s += z; // increase score for this alignment by z\n            skips += z; // increase skip count for this alignment by z\n            match_found = true;\n            break;\n          }\n          z++;\n        }\n        if (!match_found) { // the maximum number of skips has occurred with no match\n          y++; // move to next y\n          x++; // move to next x\n          s++; // increase score for this alignment by 1\n        }\n      }\n    }\n    if (s <= t) {\n      return true;\n    }\n    if (s < lowest_score) {\n      lowest_score = s;\n    }\n    y0++; // shift alignment by 1\n  }\n  return (lowest_score <= t);\n};\n\nconst sift = (powder, sieve, t) => {\n  return (powder.filter((grain) => {\n    return isMatch(grain, sieve, t);\n  }));\n}\n\nconst Nainda = {\n  isMatch,\n  sift,\n};\n"]}