{"version":3,"sources":["nainda.js"],"names":["nainda","string_1","string_2","t","a","b","length","lowest_score","a_len","b_len","n","y0","Infinity","x","i","y","s","skips","charCodeAt","a_ch","match_found","z"],"mappings":"aAAA,SAASA,OAAOC,EAAUC,EAAUC,GAClC,IAAIC,OAAAA,EADNC,OAAAA,EACMD,EAAAA,OAAGH,EAAAK,QACPF,EAAIC,EACJA,EAAIH,IAAJE,EAAAH,EAKEG,EAAIH,GAON,IAAIM,IALHC,EAAAJ,EAAAE,OAEKG,EADUH,EAAAA,OACAA,EAAhB,EAAA,EAAAH,EACMO,GAAID,EACNE,EAASC,EAAAA,EACTL,EAAAA,EAAAA,EAAAA,EAAeK,IAAAA,CAMjB,IALF,IAAKC,EAAIC,EACHD,EAAIF,EACJI,EAAIJ,EACJK,EAAO,EACPC,EAAJb,EAAec,WAAAL,GACTM,EAAOf,EAAEc,EAAWL,GAC1B,GAAAM,IAAWX,EAAAA,WAAaS,GAASJ,IAC/BE,QACEF,CAIA,IAHAE,IAAAA,EAAAA,EAFFK,GAIK,EACCC,GAAOlB,GAAA,CACX,GAAIiB,IAAAA,EAAAA,WAAJL,EAAAM,GAAA,CACAN,EAAOM,EAAKlB,EAAG,EACbU,IAAkCG,GAAAK,EAChCN,GAAIM,EACJR,GAAK,EACLG,MAEAI,IAEDA,IACDC,IACDR,IACDG,KAGEA,EAAAA,IACDT,EAAAS,GAEJL,IAECJ,OAAAA,GAAAJ","file":"nainda.min.js","sourcesContent":["function nainda(string_1, string_2, t) {\n  let a; // shorter string\n  let b; // longer string\n  if (string_2.length < string_1.length) {\n    a = string_2;\n    b = string_1;\n  }\n  else {\n    a = string_1;\n    b = string_2;\n  }\n  const a_len = a.length;\n  const b_len = b.length;\n  const n = b_len - a_len + 1 + (2 * t); // total number of alignments\n  let y0 = -t; // first index of b to be compared for this alignment\n  let lowest_score = Infinity;\n  for (let i=0; i<n; i++) {\n    let x = 0; // index of a currently being compared\n    let y = y0; // index of b currently being compared\n    let s = 0; // score for this alignment\n    let skips = 0; // skip count for this alignment\n    const a_ch = a.charCodeAt(x);\n    while (y < a_len + y0 + skips) { // go until you run out of characters in a\n      if (a_ch === b.charCodeAt(y)) { //\n        x++;\n        y++;\n      }\n      else {\n        let z = 1; // add-on to y\n        let match_found = false;\n        while (z <= t) {\n          if (a_ch === b.charCodeAt(y+z)) { // if a skip of z results in a match\n            y = y + z + 1; // set new y\n            x++; // set new x\n            s += z; // increase score for this alignment by z\n            skips += z; // increase skip count for this alignment by z\n            match_found = true;\n            break;\n          }\n          z++;\n        }\n        if (!match_found) { // the maximum number of skips has occurred with no match\n          y++; // move to next y\n          x++; // move to next x\n          s++; // increase score for this alignment by 1\n        }\n      }\n    }\n    if (s < lowest_score) {\n      lowest_score = s;\n    }\n    y0++; // shift alignment by 1\n  }\n  return (lowest_score <= t);\n};\n"]}